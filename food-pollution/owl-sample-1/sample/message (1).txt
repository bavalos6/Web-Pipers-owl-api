/*
 * This file is part of the OWL API.
 *
 * The contents of this file are subject to the LGPL License, Version 3.0.
 *
 * Copyright (C) 2011, The University of Manchester
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see http://www.gnu.org/licenses/.
 *
 *
 * Alternatively, the contents of this file may be used under the terms of the Apache License, Version 2.0
 * in which case, the provisions of the Apache License Version 2.0 are applicable instead of those above.
 *
 * Copyright 2011, The University of Manchester
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package cybershare.utep.edu;

import java.io.IOException;
import java.io.InputStream;
import java.util.Collections;
import java.util.Set;
import java.io.FileOutputStream;
import java.io.OutputStream;
import java.util.ArrayList;
import java.util.List;
import java.io.File;

import org.coode.owlapi.manchesterowlsyntax.ManchesterOWLSyntaxEditorParser;
import org.semanticweb.owlapi.apibinding.OWLManager;
import org.semanticweb.owlapi.expression.OWLEntityChecker;
import org.semanticweb.owlapi.expression.ParserException;
import org.semanticweb.owlapi.expression.ShortFormEntityChecker;
import org.semanticweb.owlapi.model.IRI;
import org.semanticweb.owlapi.model.OWLClass;
import org.semanticweb.owlapi.model.OWLClassExpression;
import org.semanticweb.owlapi.model.OWLDataFactory;
import org.semanticweb.owlapi.model.OWLEntity;
import org.semanticweb.owlapi.model.OWLNamedIndividual;
import org.semanticweb.owlapi.model.OWLOntology;
import org.semanticweb.owlapi.model.OWLOntologyCreationException;
import org.semanticweb.owlapi.model.OWLOntologyManager;
import org.semanticweb.owlapi.reasoner.Node;
import org.semanticweb.owlapi.reasoner.NodeSet;
import org.semanticweb.owlapi.reasoner.OWLReasoner;
import org.semanticweb.owlapi.util.BidirectionalShortFormProvider;
import org.semanticweb.owlapi.util.BidirectionalShortFormProviderAdapter;
import org.semanticweb.owlapi.util.ShortFormProvider;
import org.semanticweb.owlapi.util.SimpleShortFormProvider;

import org.semanticweb.HermiT.Configuration;
import org.semanticweb.HermiT.Reasoner;
import org.semanticweb.HermiT.Reasoner.ReasonerFactory;
import org.semanticweb.owlapi.model.OWLAxiom;
import org.semanticweb.owlapi.model.OWLDisjointClassesAxiom;
import org.semanticweb.owlapi.reasoner.ConsoleProgressMonitor;
import org.semanticweb.owlapi.reasoner.InferenceType;
import org.semanticweb.owlapi.util.InferredAxiomGenerator;
import org.semanticweb.owlapi.util.InferredClassAssertionAxiomGenerator;
import org.semanticweb.owlapi.util.InferredDisjointClassesAxiomGenerator;
import org.semanticweb.owlapi.util.InferredOntologyGenerator;
import org.semanticweb.owlapi.util.InferredSubClassAxiomGenerator;
import org.semanticweb.owlapi.model.OWLOntologyStorageException;
import org.semanticweb.owlapi.model.OWLDataProperty;
import org.semanticweb.owlapi.model.OWLLiteral;

/** Author: Matthew Horridge<br>
 * The University of Manchester<br>
 * Bio-Health Informatics Group<br>
 * Date: 13-May-2010 <br>
 * An example that shows how to do a Protege like DLQuery. The example contains
 * several helper classes:<br>
 * DLQueryEngine - This takes a string representing a class expression built
 * from the terms in the signature of some ontology. DLQueryPrinter - This takes
 * a string class expression and prints out the sub/super/equivalent classes and
 * the instances of the specified class expression. DLQueryParser - this parses
 * the specified class expression string */
public class MyFirstOWLAPIProgram {

    ///EDDIE: SET THESE VARIABLE NAMES TO BE BASED ON YOUR ONTOLOGY AND YOUR DIRECTORIES.
     private static final String COVID_19_ONTOLOGY = "/Users/marissaatilano/Desktop/Assignment3WithHermit/owl-team8-ontology/ontologies/COVID19_Eligibility_Ontology2.owl";
     private static final String INFERRED_COVID_19_ONTOLOGY = "/Users/marissaatilano/Desktop/Assignment3WithHermit/owl-team8-ontology/ontologies/covid19-inferred.owl";
     private static final String BASE = "http://covid19vaccinationeligibility.org/COVID19_Eligibility_Ontology.owl";

    @SuppressWarnings("javadoc")
    public static void main(String[] args) {
        try {
            
            OWLOntologyManager manager = OWLManager.createOWLOntologyManager();
            OWLOntology ontology = loadOntologyFromFile(COVID_19_ONTOLOGY, manager);
            System.out.println("Loaded ontology: " + ontology.getOntologyID());

                //EDDIE:ALL OF THIS CODE IS A PART OF THE HERMIT REASONER. KEEP IT ALL IN HERE FOR THE REASONER TO WORK.
                //EDDIE:THIS CODE IS GOING TO CREATE A HERMIT REASONER AND THEN USE IT TO CREATE AN INFERRED ONTOLOGY 
                //EDDIE:THE INFERRED ONTOLOGY WILL HAVE THE INFERENCES FOUND FROM THE HERMIT REASONER
                //EDDIE:SO THAT MEANS THAT YOU WILL WANT TO USE THE INFERRED ONTOLOGY INSTEAD OF YOUR REGULAR ONTOLOGY TO DO THE QUERIES
                //EDDIE:SINCE IT HAS THE CONNECTIONS YOU NEED
                ReasonerFactory factory = new ReasonerFactory();
                Configuration c=new Configuration();
                c.reasonerProgressMonitor=new ConsoleProgressMonitor();
                Reasoner reasoner=new Reasoner(c, ontology);
                List<InferredAxiomGenerator<? extends OWLAxiom>> generators=new ArrayList<InferredAxiomGenerator<? extends OWLAxiom>>();
                generators.add(new InferredSubClassAxiomGenerator());
                generators.add(new InferredClassAssertionAxiomGenerator());
                generators.add(new InferredDisjointClassesAxiomGenerator() {
                    boolean precomputed=false;
                    protected void addAxioms(OWLClass entity, OWLReasoner reasoner, OWLDataFactory dataFactory, Set<OWLDisjointClassesAxiom> result) {
                        if (!precomputed) {
                            reasoner.precomputeInferences(InferenceType.DISJOINT_CLASSES);
                            precomputed=true;
                        }
                        for (OWLClass cls : reasoner.getDisjointClasses(entity).getFlattened()) {
                            result.add(dataFactory.getOWLDisjointClassesAxiom(entity, cls));
                        }
                    }
                });
                InferredOntologyGenerator iog=new InferredOntologyGenerator(reasoner,generators);
                OWLOntology inferredAxiomsOntology=manager.createOntology();
                iog.fillOntology(manager.getOWLDataFactory(), inferredAxiomsOntology);
                ///EDDIE: CHANGE THIS FILE TO YOUR FILE VARIABLE NAME
                File inferredOntologyFile=new File(INFERRED_COVID_19_ONTOLOGY);
                if (!inferredOntologyFile.exists())
                    inferredOntologyFile.createNewFile();
                inferredOntologyFile=inferredOntologyFile.getAbsoluteFile();
                OutputStream outputStream=new FileOutputStream(inferredOntologyFile);
                manager.saveOntology(inferredAxiomsOntology, manager.getOntologyFormat(ontology), outputStream);
                ///EDDIE: SET YOUR ONTOLOGY EQUAL TO YOUR INFERRED ONTOLOGY BEFORE PERFORMING QUERIES
                ontology = loadOntologyFromFile(INFERRED_COVID_19_ONTOLOGY, manager);
                System.out.println("Loaded ontology: " + ontology.getOntologyID());

            ///EDDIE: THIS IS USED BY THE DLPARSER AND DLQUERYENGINE TO PARSE THE PHRASE INTO MANCHESTER SYNTAX AND RETRIEVE THE RESULTS OF THE QUERY
            ShortFormProvider shortFormProvider = new SimpleShortFormProvider();
            DLQueryEngine dlQueryEngine = new DLQueryEngine(reasoner, shortFormProvider);

            ///EDDIE: THESE ARE ALL MY METHODS AND PRINT STATEMENTS FOR PERFORMING MY SPECIFIC QUERIES. I CREATED THESE MYSELF SO YOU WILL NEED TO CREATE YOUR OWN THAT LOOK AND USE DIFFERENT NAMES THAN MINE.
            Set<OWLNamedIndividual> results1 = doQueryForQuestionOne(dlQueryEngine, "Turkovac");
            printGroupEligibilityDetails(manager, reasoner, results1);
            printDemographicEligibilityDetails(manager, reasoner, results1);
            Set<OWLNamedIndividual> results2 = doQueryForQuestionTwo(dlQueryEngine, "COVID-19");
            printVaccineDetails(manager, reasoner, results2);
            Set<OWLNamedIndividual> results3 = doQueryForQuestionThree(dlQueryEngine, "Turkovac");
            printCountryDetails(manager, reasoner, results3);
            Set<OWLNamedIndividual> results4 = doQueryForQuestionFour(dlQueryEngine, "USA", "COVID-19");
            printVaccineDetails(manager, reasoner, results4);
            Set<OWLNamedIndividual> results5 = doQueryForQuestionFive(dlQueryEngine, "Turkovac", "Turkey");
            printGroupEligibilityDetails(manager, reasoner, results5);
            Set<OWLNamedIndividual> results6 = doQueryForQuestionSix(dlQueryEngine, "Turkovac");
            printVaccineDetails(manager, reasoner, results6);
            Set<OWLNamedIndividual> results7 = doQueryForQuestionSeven(dlQueryEngine, "1");
            printCountryDetails(manager, reasoner, results7);
            Set<OWLNamedIndividual> results8 = doQueryForQuestionEight(dlQueryEngine, "16");
            printCountryDetails(manager, reasoner, results8);
            Set<OWLNamedIndividual> results9 = doQueryForQuestionNine(dlQueryEngine, "Turkovac");
            printCountryDetails(manager, reasoner, results9);
            Set<OWLNamedIndividual> results10 = doQueryForQuestionTen(dlQueryEngine, "USA");
            printDemographicEligibilityDetails(manager, reasoner, results10);

        } catch (OWLOntologyCreationException e) {
            System.out.println("Could not load ontology: " + e.getMessage());
        } catch (IOException ioEx) {
            System.out.println(ioEx.getMessage());
        }
        catch (OWLOntologyStorageException ose) {
            System.out.println("BROKEN");
        }
    }

    /**
     * Load ontology from local file
     * @param path
     * @param manager
     * @return
     * @throws OWLOntologyCreationException
     */
    public static OWLOntology loadOntologyFromFile(String path, OWLOntologyManager manager) throws OWLOntologyCreationException {
        File file = new File(path);
        // Load local ontology
        OWLOntology ontology = manager.loadOntologyFromOntologyDocument(file);
        System.out.println("Loaded ontology: " + ontology);
        // We can always obtain the location where an ontology was loaded from
        IRI documentIRI = manager.getOntologyDocumentIRI(ontology);
        System.out.println("    from: " + documentIRI);
        return ontology;
    }

    ///EDDIE: THESE ARE ALL MY METHODS AND PRINT STATEMENTS FOR PERFORMING MY SPECIFIC QUERIES. I CREATED THESE MYSELF SO YOU WILL NEED TO CREATE YOUR OWN THAT LOOK AND USE DIFFERENT NAMES THAN MINE.
    ///EDDIE: THE METHOD SENDS THE MANCHESTER SYNTAX PHRASE TO THE DLQUERY ENGINE METHOD TO GET THE SET OF OWL NAMED INDIVIDUALS
    private static Set<OWLNamedIndividual> doQueryForQuestionOne(DLQueryEngine dlQueryEngine, String vaccineName) throws IOException {
            String classExpression = "EligibilityRestrictions and isDefinedBy some (Country and administers value " + vaccineName + ")";
            Set<OWLNamedIndividual> individuals = dlQueryEngine.getQueryResults(classExpression.trim());
            System.out.println();
            return individuals;
    }

    ///EDDIE: THESE ARE ALL MY METHODS AND PRINT STATEMENTS FOR PERFORMING MY SPECIFIC QUERIES. I CREATED THESE MYSELF SO YOU WILL NEED TO CREATE YOUR OWN THAT LOOK AND USE DIFFERENT NAMES THAN MINE.
    ///EDDIE: THE METHOD SENDS THE MANCHESTER SYNTAX PHRASE TO THE DLQUERY ENGINE METHOD TO GET THE SET OF OWL NAMED INDIVIDUALS
    private static Set<OWLNamedIndividual> doQueryForQuestionTwo(DLQueryEngine dlQueryEngine, String covid19) throws IOException {
            String classExpression = "Vaccine and prevents some " + covid19;
            Set<OWLNamedIndividual> individuals = dlQueryEngine.getQueryResults(classExpression.trim());
            System.out.println();
            return individuals;
    }

    ///EDDIE: THESE ARE ALL MY METHODS AND PRINT STATEMENTS FOR PERFORMING MY SPECIFIC QUERIES. I CREATED THESE MYSELF SO YOU WILL NEED TO CREATE YOUR OWN THAT LOOK AND USE DIFFERENT NAMES THAN MINE.
    ///EDDIE: THE METHOD SENDS THE MANCHESTER SYNTAX PHRASE TO THE DLQUERY ENGINE METHOD TO GET THE SET OF OWL NAMED INDIVIDUALS
    private static Set<OWLNamedIndividual> doQueryForQuestionThree(DLQueryEngine dlQueryEngine, String vaccineName) throws IOException {
            String classExpression = "Country and administers value " + vaccineName;
            Set<OWLNamedIndividual> individuals = dlQueryEngine.getQueryResults(classExpression.trim());
            System.out.println();
            return individuals;
    }

    ///EDDIE: THESE ARE ALL MY METHODS AND PRINT STATEMENTS FOR PERFORMING MY SPECIFIC QUERIES. I CREATED THESE MYSELF SO YOU WILL NEED TO CREATE YOUR OWN THAT LOOK AND USE DIFFERENT NAMES THAN MINE.
    ///EDDIE: THE METHOD SENDS THE MANCHESTER SYNTAX PHRASE TO THE DLQUERY ENGINE METHOD TO GET THE SET OF OWL NAMED INDIVIDUALS
    private static Set<OWLNamedIndividual> doQueryForQuestionFour(DLQueryEngine dlQueryEngine, String countryCode, String covid19) throws IOException {
            String classExpression = "Vaccine and isAdministeredBy value " + countryCode + " and prevents some " + covid19;
            Set<OWLNamedIndividual> individuals = dlQueryEngine.getQueryResults(classExpression.trim());
            System.out.println();
            return individuals;
    }

    ///EDDIE: THESE ARE ALL MY METHODS AND PRINT STATEMENTS FOR PERFORMING MY SPECIFIC QUERIES. I CREATED THESE MYSELF SO YOU WILL NEED TO CREATE YOUR OWN THAT LOOK AND USE DIFFERENT NAMES THAN MINE.
    ///EDDIE: THE METHOD SENDS THE MANCHESTER SYNTAX PHRASE TO THE DLQUERY ENGINE METHOD TO GET THE SET OF OWL NAMED INDIVIDUALS
    private static Set<OWLNamedIndividual> doQueryForQuestionFive(DLQueryEngine dlQueryEngine, String vaccineName, String countryName) throws IOException {
            String classExpression = "GroupEligibility and isDefinedBy some (Country and administers value " + vaccineName + " and hasCountryName value \"" + countryName + "\")";
            Set<OWLNamedIndividual> individuals = dlQueryEngine.getQueryResults(classExpression.trim());
            System.out.println();
            return individuals;
    }

    ///EDDIE: THESE ARE ALL MY METHODS AND PRINT STATEMENTS FOR PERFORMING MY SPECIFIC QUERIES. I CREATED THESE MYSELF SO YOU WILL NEED TO CREATE YOUR OWN THAT LOOK AND USE DIFFERENT NAMES THAN MINE.
    ///EDDIE: THE METHOD SENDS THE MANCHESTER SYNTAX PHRASE TO THE DLQUERY ENGINE METHOD TO GET THE SET OF OWL NAMED INDIVIDUALS
    private static Set<OWLNamedIndividual> doQueryForQuestionSix(DLQueryEngine dlQueryEngine, String vaccineName) throws IOException {
            String classExpression = "COVID-19 and preventedBy value " + vaccineName ;
            Set<OWLNamedIndividual> individuals = dlQueryEngine.getQueryResults(classExpression.trim());
            System.out.println();
            return individuals;
    }

    ///EDDIE: THESE ARE ALL MY METHODS AND PRINT STATEMENTS FOR PERFORMING MY SPECIFIC QUERIES. I CREATED THESE MYSELF SO YOU WILL NEED TO CREATE YOUR OWN THAT LOOK AND USE DIFFERENT NAMES THAN MINE.
    ///EDDIE: THE METHOD SENDS THE MANCHESTER SYNTAX PHRASE TO THE DLQUERY ENGINE METHOD TO GET THE SET OF OWL NAMED INDIVIDUALS
    private static Set<OWLNamedIndividual> doQueryForQuestionSeven(DLQueryEngine dlQueryEngine, String policyNumber) throws IOException {
            String classExpression = "Country and defines some (GroupEligibility and hasPolicy value " + policyNumber + ")";
            Set<OWLNamedIndividual> individuals = dlQueryEngine.getQueryResults(classExpression.trim());
            System.out.println();
            return individuals;
    }

    ///EDDIE: THESE ARE ALL MY METHODS AND PRINT STATEMENTS FOR PERFORMING MY SPECIFIC QUERIES. I CREATED THESE MYSELF SO YOU WILL NEED TO CREATE YOUR OWN THAT LOOK AND USE DIFFERENT NAMES THAN MINE.
    ///EDDIE: THE METHOD SENDS THE MANCHESTER SYNTAX PHRASE TO THE DLQUERY ENGINE METHOD TO GET THE SET OF OWL NAMED INDIVIDUALS
    private static Set<OWLNamedIndividual> doQueryForQuestionEight(DLQueryEngine dlQueryEngine, String age) throws IOException {
            String classExpression = "Country and defines some (DemographicEligibility and hasMinimumAge some xsd:integer[>=" + age + "])";
            Set<OWLNamedIndividual> individuals = dlQueryEngine.getQueryResults(classExpression.trim());
            System.out.println();
            return individuals;
    }

    ///EDDIE: THESE ARE ALL MY METHODS AND PRINT STATEMENTS FOR PERFORMING MY SPECIFIC QUERIES. I CREATED THESE MYSELF SO YOU WILL NEED TO CREATE YOUR OWN THAT LOOK AND USE DIFFERENT NAMES THAN MINE.
    ///EDDIE: THE METHOD SENDS THE MANCHESTER SYNTAX PHRASE TO THE DLQUERY ENGINE METHOD TO GET THE SET OF OWL NAMED INDIVIDUALS
    private static Set<OWLNamedIndividual> doQueryForQuestionNine(DLQueryEngine dlQueryEngine, String vaccineName) throws IOException {
            String classExpression = "Country and defines some ((GroupEligibility and hasPolicy value 4) or (GroupEligibility and hasPolicy value 3) or (GroupEligibility and hasPolicy value 2) or (GroupEligibility and hasPolicy value 1))";
            Set<OWLNamedIndividual> individuals = dlQueryEngine.getQueryResults(classExpression.trim());
            System.out.println();
            return individuals;
    }

    ///EDDIE: THESE ARE ALL MY METHODS AND PRINT STATEMENTS FOR PERFORMING MY SPECIFIC QUERIES. I CREATED THESE MYSELF SO YOU WILL NEED TO CREATE YOUR OWN THAT LOOK AND USE DIFFERENT NAMES THAN MINE.
    ///EDDIE: THE METHOD SENDS THE MANCHESTER SYNTAX PHRASE TO THE DLQUERY ENGINE METHOD TO GET THE SET OF OWL NAMED INDIVIDUALS
    private static Set<OWLNamedIndividual> doQueryForQuestionTen(DLQueryEngine dlQueryEngine, String countryCode) throws IOException {
            String classExpression = "DemographicEligibility and isDefinedBy value " + countryCode;
            Set<OWLNamedIndividual> individuals = dlQueryEngine.getQueryResults(classExpression.trim());
            System.out.println();
            return individuals;
    }

    ///EDDIE: THESE ARE ALL MY METHODS AND PRINT STATEMENTS FOR PERFORMING MY SPECIFIC QUERIES. I CREATED THESE MYSELF SO YOU WILL NEED TO CREATE YOUR OWN THAT LOOK AND USE DIFFERENT NAMES THAN MINE.
    ///EDDIE: THE METHOD SENDS THE MANCHESTER SYNTAX PHRASE TO THE DLQUERY ENGINE METHOD TO GET THE SET OF OWL NAMED INDIVIDUALS
    private static void printDemographicEligibilityDetails(OWLOntologyManager manager, OWLReasoner reasoner, Set<OWLNamedIndividual> individuals) throws IOException {
            for (OWLNamedIndividual individual : individuals){
                //Gets the value of the hasMinimumAge Data Property
                OWLDataProperty minAgeProperty = manager.getOWLDataFactory().getOWLDataProperty(IRI.create(BASE + "#" + "hasMinimumAge"));
                Set<OWLLiteral> minAgeValue = reasoner.getDataPropertyValues( individual, minAgeProperty );
                //Gets the value of the hasDate Data Property
                OWLDataProperty dateProperty = manager.getOWLDataFactory().getOWLDataProperty(IRI.create(BASE + "#" + "hasDate"));
                Set<OWLLiteral> dateValue = reasoner.getDataPropertyValues( individual, dateProperty );
                //Prints the values of the instance
                System.out.println("Individual Name: " + individual.getIRI().getFragment());
                System.out.println("Individual MinimumAge: " + minAgeValue);
                System.out.println("Individual Date: " + dateValue);            
            }
            System.out.println();
    }

    ///EDDIE: THESE ARE ALL MY METHODS AND PRINT STATEMENTS FOR PERFORMING MY SPECIFIC QUERIES. I CREATED THESE MYSELF SO YOU WILL NEED TO CREATE YOUR OWN THAT LOOK AND USE DIFFERENT NAMES THAN MINE.
    ///EDDIE: THE METHOD SENDS THE MANCHESTER SYNTAX PHRASE TO THE DLQUERY ENGINE METHOD TO GET THE SET OF OWL NAMED INDIVIDUALS
    private static void printGroupEligibilityDetails(OWLOntologyManager manager, OWLReasoner reasoner, Set<OWLNamedIndividual> individuals) throws IOException {
            for (OWLNamedIndividual individual : individuals){
                //Gets the value of the hasPolicy Data Property
                OWLDataProperty policyProperty = manager.getOWLDataFactory().getOWLDataProperty(IRI.create(BASE + "#" + "hasPolicy"));
                Set<OWLLiteral> policyValue = reasoner.getDataPropertyValues( individual, policyProperty );
                //Gets the value of the hasDate Data Property
                OWLDataProperty dateProperty = manager.getOWLDataFactory().getOWLDataProperty(IRI.create(BASE + "#" + "hasDate"));
                Set<OWLLiteral> dateValue = reasoner.getDataPropertyValues( individual, dateProperty );
                //Prints the values of the instance
                System.out.println("Individual Name: " + individual.getIRI().getFragment());
                System.out.println("Individual Policy: " + policyValue);
                System.out.println("Individual Date: " + dateValue);            
            }
            System.out.println();
    }

    ///EDDIE: THESE ARE ALL MY METHODS AND PRINT STATEMENTS FOR PERFORMING MY SPECIFIC QUERIES. I CREATED THESE MYSELF SO YOU WILL NEED TO CREATE YOUR OWN THAT LOOK AND USE DIFFERENT NAMES THAN MINE.
    ///EDDIE: THE METHOD SENDS THE MANCHESTER SYNTAX PHRASE TO THE DLQUERY ENGINE METHOD TO GET THE SET OF OWL NAMED INDIVIDUALS
    private static void printCountryDetails(OWLOntologyManager manager, OWLReasoner reasoner, Set<OWLNamedIndividual> individuals) throws IOException {
            for (OWLNamedIndividual individual : individuals){
                //Gets the value of the hasCountryName Data Property
                OWLDataProperty countryNameProperty = manager.getOWLDataFactory().getOWLDataProperty(IRI.create(BASE + "#" + "hasCountryName"));
                Set<OWLLiteral> countryNameValue = reasoner.getDataPropertyValues( individual, countryNameProperty );
                //Prints the values of the instance
                System.out.println("Individual Name: " + individual.getIRI().getFragment());
                System.out.println("Individual Country Name: " + countryNameValue);
            }
            System.out.println();
    }

    ///EDDIE: THESE ARE ALL MY METHODS AND PRINT STATEMENTS FOR PERFORMING MY SPECIFIC QUERIES. I CREATED THESE MYSELF SO YOU WILL NEED TO CREATE YOUR OWN THAT LOOK AND USE DIFFERENT NAMES THAN MINE.
    ///EDDIE: THE METHOD SENDS THE MANCHESTER SYNTAX PHRASE TO THE DLQUERY ENGINE METHOD TO GET THE SET OF OWL NAMED INDIVIDUALS
    private static void printVaccineDetails(OWLOntologyManager manager, OWLReasoner reasoner, Set<OWLNamedIndividual> individuals) throws IOException {
            for (OWLNamedIndividual individual : individuals){
                //Prints the values of the instance
                System.out.println("Individual Name: " + individual.getIRI().getFragment());
            }
            System.out.println();
    }

}

///EDDIE: THIS CODE IS FROM THE GITHUB REPO I SENT YOU FOR DLQUERY ENGINE. YOU CAN LEAVE ALL OF IT THE SAME EXCEPT GETQUERYRESULTS

/** This example shows how to perform a "dlquery". The DLQuery view/tab in
 * Protege 4 works like this. */
class DLQueryEngine {
    private final OWLReasoner reasoner;
    private final DLQueryParser parser;

    /** Constructs a DLQueryEngine. This will answer "DL queries" using the
     * specified reasoner. A short form provider specifies how entities are
     * rendered.
     * 
     * @param reasoner
     *            The reasoner to be used for answering the queries.
     * @param shortFormProvider
     *            A short form provider. */
    public DLQueryEngine(OWLReasoner reasoner, ShortFormProvider shortFormProvider) {
        this.reasoner = reasoner;
        OWLOntology rootOntology = reasoner.getRootOntology();
        parser = new DLQueryParser(rootOntology, shortFormProvider);
    }

    /** Gets the superclasses of a class expression parsed from a string.
     * 
     * @param classExpressionString
     *            The string from which the class expression will be parsed.
     * @param direct
     *            Specifies whether direct superclasses should be returned or
     *            not.
     * @return The superclasses of the specified class expression
     * @throws ParserException
     *             If there was a problem parsing the class expression. */
    public Set<OWLClass> getSuperClasses(String classExpressionString, boolean direct)
            throws ParserException {
        if (classExpressionString.trim().length() == 0) {
            return Collections.emptySet();
        }
        OWLClassExpression classExpression = parser
                .parseClassExpression(classExpressionString);
        NodeSet<OWLClass> superClasses = reasoner
                .getSuperClasses(classExpression, direct);
        return superClasses.getFlattened();
    }

    /** Gets the equivalent classes of a class expression parsed from a string.
     * 
     * @param classExpressionString
     *            The string from which the class expression will be parsed.
     * @return The equivalent classes of the specified class expression
     * @throws ParserException
     *             If there was a problem parsing the class expression. */
    public Set<OWLClass> getEquivalentClasses(String classExpressionString)
            throws ParserException {
        if (classExpressionString.trim().length() == 0) {
            return Collections.emptySet();
        }
        OWLClassExpression classExpression = parser
                .parseClassExpression(classExpressionString);
        Node<OWLClass> equivalentClasses = reasoner.getEquivalentClasses(classExpression);
        Set<OWLClass> result;
        if (classExpression.isAnonymous()) {
            result = equivalentClasses.getEntities();
        } else {
            result = equivalentClasses.getEntitiesMinus(classExpression.asOWLClass());
        }
        return result;
    }

    /** Gets the subclasses of a class expression parsed from a string.
     * 
     * @param classExpressionString
     *            The string from which the class expression will be parsed.
     * @param direct
     *            Specifies whether direct subclasses should be returned or not.
     * @return The subclasses of the specified class expression
     * @throws ParserException
     *             If there was a problem parsing the class expression. */
    public Set<OWLClass> getSubClasses(String classExpressionString, boolean direct)
            throws ParserException {
        if (classExpressionString.trim().length() == 0) {
            return Collections.emptySet();
        }
        OWLClassExpression classExpression = parser
                .parseClassExpression(classExpressionString);
        NodeSet<OWLClass> subClasses = reasoner.getSubClasses(classExpression, direct);
        return subClasses.getFlattened();
    }

    /** Gets the instances of a class expression parsed from a string.
     * 
     * @param classExpressionString
     *            The string from which the class expression will be parsed.
     * @param direct
     *            Specifies whether direct instances should be returned or not.
     * @return The instances of the specified class expression
     * @throws ParserException
     *             If there was a problem parsing the class expression. */
    public Set<OWLNamedIndividual> getInstances(String classExpressionString,
            boolean direct) throws ParserException {
        if (classExpressionString.trim().length() == 0) {
            return Collections.emptySet();
        }
        OWLClassExpression classExpression = parser
                .parseClassExpression(classExpressionString);
        NodeSet<OWLNamedIndividual> individuals = reasoner.getInstances(classExpression,
                direct);
        return individuals.getFlattened();
    }

    ///EDDIE: I CREATED THIS METHOD TO TAKE IN A CLASS EXPRESSION AND GET THE INSTANCES OF THAT CLASS EXPRESSION.
    ///EDDIE: YOU WILL HAVE TO IMPLEMENT THIS ON YOUR OWN AND MAKE IT LOOK DIFFERENT THAN MINE.
    ///EDDIE: YOU ALSO DONT HAVE TO DO GETINSTANCES, YOU CAN DO GETSUPERCLASSES OR GETSUBCLASSES OR GETEQUIVALENTCLASSES
    public Set<OWLNamedIndividual> getQueryResults(String classExpression) {
        Set<OWLNamedIndividual> individuals = getInstances(classExpression, true);
        return individuals;
    }
}

///EDDIE: THIS CODE IS FROM THE GITHUB REPO I SENT YOU FOR DLQUERY ENGINE. YOU CAN LEAVE ALL OF IT THE SAME
class DLQueryParser {
    private final OWLOntology rootOntology;
    private final BidirectionalShortFormProvider bidiShortFormProvider;

    /** Constructs a DLQueryParser using the specified ontology and short form
     * provider to map entity IRIs to short names.
     * 
     * @param rootOntology
     *            The root ontology. This essentially provides the domain
     *            vocabulary for the query.
     * @param shortFormProvider
     *            A short form provider to be used for mapping back and forth
     *            between entities and their short names (renderings). */
    public DLQueryParser(OWLOntology rootOntology, ShortFormProvider shortFormProvider) {
        this.rootOntology = rootOntology;
        OWLOntologyManager manager = rootOntology.getOWLOntologyManager();
        Set<OWLOntology> importsClosure = rootOntology.getImportsClosure();
        // Create a bidirectional short form provider to do the actual mapping.
        // It will generate names using the input
        // short form provider.
        bidiShortFormProvider = new BidirectionalShortFormProviderAdapter(manager,
                importsClosure, shortFormProvider);
    }

    /** Parses a class expression string to obtain a class expression.
     * 
     * @param classExpressionString
     *            The class expression string
     * @return The corresponding class expression
     * @throws ParserException
     *             if the class expression string is malformed or contains
     *             unknown entity names. */
    public OWLClassExpression parseClassExpression(String classExpressionString)
            throws ParserException {
        OWLDataFactory dataFactory = rootOntology.getOWLOntologyManager()
                .getOWLDataFactory();
        // Set up the real parser
        ManchesterOWLSyntaxEditorParser parser = new ManchesterOWLSyntaxEditorParser(
                dataFactory, classExpressionString);
        parser.setDefaultOntology(rootOntology);
        // Specify an entity checker that wil be used to check a class
        // expression contains the correct names.
        OWLEntityChecker entityChecker = new ShortFormEntityChecker(bidiShortFormProvider);
        parser.setOWLEntityChecker(entityChecker);
        // Do the actual parsing
        return parser.parseClassExpression();
    }
}

